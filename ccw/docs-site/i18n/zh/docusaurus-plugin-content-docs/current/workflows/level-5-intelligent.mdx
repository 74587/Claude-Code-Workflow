---
title: "层级 5: 智能工作流"
description: "智能编排工作流 - 自动分析和推荐"
sidebar_position: 6
---

import Mermaid from '@theme/Mermaid';

# 层级 5: 智能工作流

**复杂度**: 所有层级 | **产物**: 完整状态持久化 | **自动化**: 完全自动化

层级 5 工作流提供最智能的自动化功能 - 带有顺序执行和状态持久化的自动命令链编排。它们能够自动分析需求、推荐最优命令链，并端到端执行。

## 概述

<Mermaid
  chart={`
    flowchart TD
        Start([用户输入]) --> Analyze[阶段 1: 分析<br/>需求]
        Analyze --> Recommend[阶段 2: 发现命令<br/>& 推荐命令链]
        Recommend --> Confirm[用户确认<br/>可选]
        Confirm --> Execute[阶段 3: 顺序执行<br/>命令链]

        Execute --> State[状态持久化<br/>state.json]
        State --> Check{完成?}
        Check -->|否| Execute
        Check -->|是| Complete([完成])

        classDef startend fill:#c8e6c9,stroke:#388e3c
        classDef phase fill:#e3f2fd,stroke:#1976d2
        classDef decision fill:#fff9c4,stroke:#f57c00
        classDef state fill:#ffecb3,stroke:#ffa000

        class Start,Complete startend,Confirm,Check decision,Analyze,Recommend,Execute phase,State state
  `}
/>

## 包含的工作流: ccw-coordinator

**自动分析并推荐命令链，支持顺序执行**

### 命令

```bash
/ccw-coordinator "使用 OAuth2 实现用户认证"
# 或者简单输入
/ccw "添加用户认证"
```

### 核心概念: 最小执行单元

**定义**: 一组必须作为原子组一起执行的命令，以实现有意义的工作流里程碑。

**为什么重要**:
- **防止不完整状态**: 避免在生成任务后停止而不执行
- **用户体验**: 用户获得完整结果，而非需要手动跟进的中间产物
- **工作流完整性**: 保持多步骤操作的逻辑连贯性

### 最小执行单元

#### 规划 + 执行单元

| 单元名称 | 命令 | 目的 | 输出 |
|-----------|----------|---------|--------|
| **快速实现** | lite-plan -> lite-execute | 轻量级规划和立即执行 | 工作代码 |
| **多 CLI 规划** | multi-cli-plan -> lite-execute | 多视角分析和执行 | 工作代码 |
| **Bug 修复** | lite-fix -> lite-execute | 快速 bug 诊断和修复执行 | 修复后的代码 |
| **完整规划 + 执行** | plan -> execute | 详细规划和执行 | 工作代码 |
| **验证规划 + 执行** | plan -> plan-verify -> execute | 带验证的规划和执行 | 工作代码 |
| **重新规划 + 执行** | replan -> execute | 更新计划并执行变更 | 工作代码 |
| **TDD 规划 + 执行** | tdd-plan -> execute | 测试驱动开发规划和执行 | 工作代码 |
| **测试生成 + 执行** | test-gen -> execute | 生成测试套件并执行 | 生成的测试 |

#### 测试单元

| 单元名称 | 命令 | 目的 | 输出 |
|-----------|----------|---------|--------|
| **测试验证** | test-fix-gen -> test-cycle-execute | 生成测试任务并执行测试-修复循环 | 测试通过 |

#### 审查单元

| 单元名称 | 命令 | 目的 | 输出 |
|-----------|----------|---------|--------|
| **代码审查 (会话)** | review-session-cycle -> review-fix | 完整审查循环并应用修复 | 修复后的代码 |
| **代码审查 (模块)** | review-module-cycle -> review-fix | 模块审查循环并应用修复 | 修复后的代码 |

### 三阶段工作流

<Mermaid
  chart={`
    flowchart TD
        A([开始]) --> B[阶段 1: 分析需求]

        B --> C[解析任务描述]
        C --> D[提取: 目标、范围、约束、<br/>复杂度、任务类型]

        D --> E[阶段 2: 发现命令<br/>& 推荐命令链]

        E --> F[动态命令链<br/>组装]
        F --> G[基于端口匹配]

        G --> H{用户确认}
        H -->|确认| I[阶段 3: 顺序执行<br/>命令链]
        H -->|调整| J[修改命令链]
        H -->|取消| K([中止])
        J --> H

        I --> L[初始化状态]
        L --> M[遍历每个命令]
        M --> N[组装提示词]
        N --> O[在后台启动 CLI]
        O --> P[保存检查点]
        P --> Q{完成?}
        Q -->|否| M
        Q -->|是| R([完成])

        classDef startend fill:#c8e6c9,stroke:#388e3c
        classDef phase fill:#e3f2fd,stroke:#1976d2
        classDef decision fill:#fff9c4,stroke:#f57c00
        classDef execute fill:#c5e1a5,stroke:#388e3c

        class A,K,R startend,H,Q decision,B,E,I phase,C,D,F,G,J,L,M,N,O,P execute
  `}
/>

#### 阶段 1: 分析需求

解析任务描述以提取: 目标、范围、约束、复杂度和任务类型。

```javascript
function analyzeRequirements(taskDescription) {
  return {
    goal: extractMainGoal(taskDescription),           // 例如: "实现用户注册"
    scope: extractScope(taskDescription),             // 例如: ["auth", "user_management"]
    constraints: extractConstraints(taskDescription), // 例如: ["无破坏性变更"]
    complexity: determineComplexity(taskDescription), // 'simple' | 'medium' | 'complex'
    task_type: detectTaskType(taskDescription)        // 见下方的任务类型模式
  };
}

// 任务类型检测模式
function detectTaskType(text) {
  // 优先顺序 (第一个匹配胜出)
  if (/fix|bug|error|crash|fail|debug|diagnose/.test(text)) return 'bugfix';
  if (/tdd|test-driven|test first/.test(text)) return 'tdd';
  if (/test fail|fix test|failing test/.test(text)) return 'test-fix';
  if (/generate test|add test/.test(text)) return 'test-gen';
  if (/review/.test(text)) return 'review';
  if (/explore|brainstorm/.test(text)) return 'brainstorm';
  if (/multi-perspective|comparison/.test(text)) return 'multi-cli';
  return 'feature';  // 默认
}

// 复杂度评估
function determineComplexity(text) {
  let score = 0;
  if (/refactor|migrate|architect|system/.test(text)) score += 2;
  if (/multiple|across|all|entire/.test(text)) score += 2;
  if (/integrate|api|database/.test(text)) score += 1;
  if (/security|performance|scale/.test(text)) score += 1;
  return score >= 4 ? 'complex' : score >= 2 ? 'medium' : 'simple';
}
```

#### 阶段 2: 发现命令并推荐命令链

使用基于端口匹配的动态命令链组装。

**向用户显示**:
```
推荐命令链:

管道 (可视化):
需求 -> lite-plan -> 计划 -> lite-execute -> 代码 -> test-cycle-execute -> 测试通过

命令:
1. /workflow:lite-plan
2. /workflow:lite-execute
3. /workflow:test-cycle-execute

继续? [确认 / 显示详情 / 调整 / 取消]
```

#### 阶段 3: 顺序执行命令链

```javascript
async function executeCommandChain(chain, analysis) {
  const sessionId = `ccw-coord-${Date.now()}`;
  const stateDir = `.workflow/.ccw-coordinator/${sessionId}`;

  // 初始化状态
  const state = {
    session_id: sessionId,
    status: 'running',
    created_at: new Date().toISOString(),
    analysis: analysis,
    command_chain: chain.map((cmd, idx) => ({ ...cmd, index: idx, status: 'pending' })),
    execution_results: [],
    prompts_used: []
  };

  // 保存初始状态
  Write(`${stateDir}/state.json`, JSON.stringify(state, null, 2));

  for (let i = 0; i < chain.length; i++) {
    const cmd = chain[i];

    // 组装提示词
    let prompt = formatCommand(cmd, state.execution_results, analysis);
    prompt += `\n\nTask: ${analysis.goal}`;
    if (state.execution_results.length > 0) {
      prompt += '\nPrevious results:\n';
      state.execution_results.forEach(r => {
        if (r.session_id) {
          prompt += `- ${r.command}: ${r.session_id}\n`;
        }
      });
    }

    // 在后台启动 CLI
    const taskId = Bash(
      `ccw cli -p "${escapePrompt(prompt)}" --tool claude --mode write`,
      { run_in_background: true }
    ).task_id;

    // 保存检查点
    state.execution_results.push({
      index: i,
      command: cmd.command,
      status: 'in-progress',
      task_id: taskId,
      session_id: null,
      artifacts: [],
      timestamp: new Date().toISOString()
    });

    // 在此停止 - 等待 hook 回调
    Write(`${stateDir}/state.json`, JSON.stringify(state, null, 2));
    break;
  }

  state.status = 'waiting';
  Write(`${stateDir}/state.json`, JSON.stringify(state, null, 2));
  return state;
}
```

### 状态文件结构

**位置**: `.workflow/.ccw-coordinator/{session_id}/state.json`

```json
{
  "session_id": "ccw-coord-20250203-143025",
  "status": "running|waiting|completed|failed",
  "created_at": "2025-02-03T14:30:25Z",
  "updated_at": "2025-02-03T14:35:45Z",
  "analysis": {
    "goal": "实现用户注册",
    "scope": ["authentication", "user_management"],
    "constraints": ["无破坏性变更"],
    "complexity": "medium",
    "task_type": "feature"
  },
  "command_chain": [
    {
      "index": 0,
      "command": "/workflow:plan",
      "name": "plan",
      "status": "completed"
    },
    {
      "index": 1,
      "command": "/workflow:execute",
      "name": "execute",
      "status": "running"
    }
  ],
  "execution_results": [
    {
      "index": 0,
      "command": "/workflow:plan",
      "status": "completed",
      "task_id": "task-001",
      "session_id": "WFS-plan-20250203",
      "artifacts": ["IMPL_PLAN.md"],
      "timestamp": "2025-02-03T14:30:25Z",
      "completed_at": "2025-02-03T14:30:45Z"
    }
  ]
}
```

### 完整生命周期决策流程图

<Mermaid
  chart={`
    flowchart TD
        Start([开始新任务]) --> Q0{是 bug 修复吗?}

        Q0 -->|是| BugFix["Bug 修复流程"]
        Q0 -->|否| Q1{知道要做什么吗?}

        BugFix --> BugSeverity{理解根本原因吗?}
        BugSeverity -->|清楚| LiteFix["/workflow:lite-fix<br/>标准修复"]
        BugSeverity -->|生产事故| HotFix["/workflow:lite-fix --hotfix<br/>紧急热修复"]
        BugSeverity -->|不清楚| BugDiag["/workflow:lite-fix<br/>自动诊断根本原因"]

        BugDiag --> LiteFix
        LiteFix --> BugComplete["Bug 已修复"]
        HotFix --> FollowUp["自动生成后续任务<br/>完整修复 + 复盘"]
        FollowUp --> BugComplete
        BugComplete --> End(["任务完成"])

        Q1 -->|否| Ideation["探索阶段<br/>明确需求"]
        Q1 -->|是| Q2{知道如何做吗?}

        Ideation --> BrainIdea["/workflow:brainstorm:auto-parallel<br/>探索产品方向"]
        BrainIdea --> Q2

        Q2 -->|否| Design["设计探索<br/>探索架构"]
        Q2 -->|是| Q3{需要规划吗?}

        Design --> BrainDesign["/workflow:brainstorm:auto-parallel<br/>探索技术方案"]
        BrainDesign --> Q3

        Q3 -->|快速简单| LitePlan["轻量级规划<br/>/workflow:lite-plan"]
        Q3 -->|复杂完整| FullPlan["标准规划<br/>/workflow:plan"]

        LitePlan --> Q4{需要代码探索?}
        Q4 -->|是| LitePlanE["/workflow:lite-plan -e"]
        Q4 -->|否| LitePlanNormal["/workflow:lite-plan"]

        LitePlanE --> LiteConfirm["三维确认:<br/>1. 任务确认<br/>2. 执行方式<br/>3. 代码审查"]
        LitePlanNormal --> LiteConfirm

        LiteConfirm --> Q5{选择执行方式}
        Q5 -->|Agent| LiteAgent["/workflow:lite-execute<br/>使用 @code-developer"]
        Q5 -->|CLI 工具| LiteCLI["CLI 执行<br/>Gemini/Qwen/Codex"]
        Q5 -->|仅规划| UserImpl["用户手动实现"]

        FullPlan --> PlanVerify{验证计划质量?}
        PlanVerify -->|是| Verify["/workflow:plan-verify"]
        PlanVerify -->|否| Execute
        Verify --> Q6{验证通过?}
        Q6 -->|否| FixPlan["修复计划问题"]
        Q6 -->|是| Execute
        FixPlan --> Execute

        Execute["执行阶段<br/>/workflow:execute"]
        LiteAgent --> TestDecision
        LiteCLI --> TestDecision
        UserImpl --> TestDecision
        Execute --> TestDecision

        TestDecision{需要测试?}
        TestDecision -->|TDD 模式| TDD["/workflow:tdd-plan<br/>测试驱动开发"]
        TestDecision -->|后置测试| TestGen["/workflow:test-gen<br/>生成测试"]
        TestDecision -->|已有测试| TestCycle["/workflow:test-cycle-execute<br/>测试-修复循环"]
        TestDecision -->|不需要| Review

        TDD --> TDDExecute["/workflow:execute<br/>红-绿-重构"]
        TDDExecute --> TDDVerify["/workflow:tdd-verify<br/>验证 TDD 合规性"]
        TDDVerify --> Review

        TestGen --> TestExecute["/workflow:execute<br/>执行测试任务"]
        TestExecute --> TestResult{测试通过?}
        TestResult -->|否| TestCycle
        TestResult -->|是| Review

        TestCycle --> TestPass{通过率 >= 95%?}
        TestPass -->|否, 继续修复| TestCycle
        TestPass -->|是| Review

        Review["审查阶段"]
        Review --> Q7{需要专项审查?}
        Q7 -->|安全| SecurityReview["/workflow:review<br/>--type security"]
        Q7 -->|架构| ArchReview["/workflow:review<br/>--type architecture"]
        Q7 -->|质量| QualityReview["/workflow:review<br/>--type quality"]
        Q7 -->|通用| GeneralReview["/workflow:review<br/>通用审查"]
        Q7 -->|不需要| Complete

        SecurityReview --> Complete
        ArchReview --> Complete
        QualityReview --> Complete
        GeneralReview --> Complete

        Complete["完成阶段<br/>/workflow:session:complete"]
        Complete --> End

        classDef startend fill:#c8e6c9,stroke:#388e3c
        classDef bugfix fill:#ffccbc,stroke:#bf360c
        classDef ideation fill:#fff9c4,stroke:#ffa000
        classDef planning fill:#e3f2fd,stroke:#1976d2
        classDef execute fill:#c5e1a5,stroke:#388e3c
        classDef review fill:#d1c4e9,stroke:#512da8

        class Start,End startend,BugFix,LiteFix,HotFix,BugDiag,BugComplete bugfix,Ideation,BrainIdea,BrainDesign ideation,LitePlan,LitePlanE,LitePlanNormal,LiteConfirm,FullPlan,PlanVerify,Verify,FixPlan planning,Execute,LiteAgent,LiteCLI,UserImpl,TDD,TDDExecute,TDDVerify,TestGen,TestExecute,TestCycle execute,Review,SecurityReview,ArchReview,QualityReview,GeneralReview,Complete review
  `}
/>

### 使用场景

### 何时使用

- 复杂的多步骤工作流
- 不确定使用哪些命令
- 需要端到端自动化
- 需要完整的状态跟踪和可恢复性
- 团队协作需要统一的执行流程

### 何时不使用

- 简单的单命令任务 (直接使用层级 1-4)
- 已经知道确切的所需命令 (直接使用层级 1-4)

### 与其他层级的关系

| 层级 | 手动程度 | CCW Coordinator 角色 |
|-------|---------------|-----------------------|
| 层级 1-4 | 手动选择命令 | 自动组合这些命令 |
| 层级 5 | 自动选择命令 | 智能编排器 |

**CCW Coordinator 内部使用层级 1-4**:
- 分析任务 -> 自动选择合适的层级
- 组装命令链 -> 包含层级 1-4 的命令
- 顺序执行 -> 遵循最小执行单元

## 相关工作流

- [层级 1: 超轻量级](./level-1-ultra-lightweight.mdx) - 快速执行
- [层级 2: 快速](./level-2-rapid.mdx) - 轻量级规划
- [层级 3: 标准](./level-3-standard.mdx) - 完整规划
- [层级 4: 头脑风暴](./level-4-brainstorm.mdx) - 多角色探索
- [常见问题](./faq.mdx) - 常见问题

## 命令参考

参见 [命令文档](../commands/general/ccw.mdx) 了解:
- `/ccw-coordinator` - 智能工作流编排器
- `/ccw` - 主工作流编排器
