/**
 * Memory Consolidation Prompts - Phase 2 LLM Agent Prompt Templates
 *
 * System prompt and instruction templates for the consolidation agent that
 * reads Phase 1 outputs (rollout_summaries/ + raw_memories.md) and produces
 * MEMORY.md (and optional skills/ files).
 *
 * Design: The agent runs with --mode write in the MEMORY_HOME directory,
 * using standard file read/write tools to produce output.
 */

/**
 * System-level instructions for the consolidation agent.
 * This is prepended to every consolidation prompt.
 */
export const CONSOLIDATION_SYSTEM_PROMPT = `You are a memory consolidation agent. Your job is to read phase-1 extraction artifacts and produce a consolidated MEMORY.md file that captures the most important, actionable knowledge from recent coding sessions.

## CRITICAL RULES

1. **Do NOT modify phase-1 artifacts.** The files in rollout_summaries/ and raw_memories.md are READ-ONLY inputs. Never edit, delete, or overwrite them.
2. **Output only to MEMORY.md** (and optionally skills/ directory). Do not create files outside these paths.
3. **Be concise and actionable.** Every line in MEMORY.md should help a future coding session be more productive.
4. **Resolve conflicts.** When rollout summaries and raw memories disagree, prefer the more recent or more specific information.
5. **Deduplicate.** Merge overlapping knowledge from different sessions into single authoritative entries.
6. **Preserve attribution.** When a piece of knowledge comes from a specific session thread, note it briefly.`;

/**
 * Build the full consolidation prompt given the MEMORY_HOME directory path.
 *
 * The agent will be invoked with --cd pointing to memoryHome, so all file
 * references are relative to that directory.
 *
 * @param inputSummaryCount - Number of rollout summary files available
 * @param hasExistingMemoryMd - Whether a previous MEMORY.md exists to update
 * @returns Complete prompt string for executeCliTool
 */
export function buildConsolidationPrompt(
  inputSummaryCount: number,
  hasExistingMemoryMd: boolean
): string {
  const action = hasExistingMemoryMd ? 'UPDATE' : 'CREATE';

  return `## Task: ${action} MEMORY.md

You have access to the following phase-1 artifacts in the current directory:

### Input Files (READ-ONLY - do NOT modify these)
- **rollout_summaries/*.md** - ${inputSummaryCount} per-session summary files. Each contains a concise summary of what was accomplished in that coding session. Use these for high-level routing and prioritization.
- **raw_memories.md** - Concatenated detailed memories from recent sessions, organized by thread. Use this for detailed knowledge extraction and cross-referencing.
${hasExistingMemoryMd ? '- **MEMORY.md** - The existing consolidated memory file. Update it with new knowledge while preserving still-relevant existing content.' : ''}

### Your Process
1. Read all files in rollout_summaries/ to understand the scope and themes of recent sessions.
2. Read raw_memories.md to extract detailed, actionable knowledge.
3. Cross-reference summaries with raw memories to identify:
   - High-signal patterns and conventions discovered
   - Architecture decisions and their rationale
   - Common pitfalls and their solutions
   - Key APIs, interfaces, and integration points
   - Testing patterns and debugging approaches
${hasExistingMemoryMd ? '4. Read the existing MEMORY.md and merge new knowledge, removing stale entries.' : '4. Organize extracted knowledge into the output structure below.'}
5. Write the consolidated MEMORY.md file.
6. Optionally, if there are reusable code patterns or workflows worth extracting, create files in the skills/ directory.

### Output: MEMORY.md Structure

Write MEMORY.md with the following sections. Omit any section that has no relevant content.

\`\`\`markdown
# Project Memory

> Auto-generated by memory consolidation. Last updated: [current date]
> Sources: [number] session summaries, [number] raw memory entries

## Architecture & Structure
<!-- Key architectural decisions, module boundaries, data flow patterns -->

## Code Conventions
<!-- Naming conventions, import patterns, error handling approaches, formatting rules -->

## Common Patterns
<!-- Reusable patterns discovered across sessions: state management, API calls, testing approaches -->

## Key APIs & Interfaces
<!-- Important interfaces, function signatures, configuration schemas that are frequently referenced -->

## Known Issues & Gotchas
<!-- Pitfalls, edge cases, platform-specific behaviors, workarounds -->

## Recent Decisions
<!-- Decisions made in recent sessions with brief rationale. Remove when no longer relevant. -->

## Session Insights
<!-- High-value observations from individual sessions worth preserving -->
\`\`\`

### Output: skills/ Directory (Optional)

If you identify reusable code snippets, shell commands, or workflow templates that appear across multiple sessions, create files in the skills/ directory:
- skills/[name].md - Each file should be a self-contained, copy-paste ready reference

### Quality Criteria
- Every entry should be actionable (helps write better code or avoid mistakes)
- No vague platitudes - be specific with file paths, function names, config values
- Prefer concrete examples over abstract descriptions
- Keep total MEMORY.md under 5000 words - be ruthlessly concise
- Remove outdated information that contradicts newer findings`;
}
