{
  "success": true,
  "result": {
    "query": "class Config",
    "method": "cascade",
    "count": 10,
    "results": [
      {
        "path": "D:\\Claude_dms3\\codex-lens\\src\\codexlens\\hybrid_search\\data_structures.py",
        "score": 0.06081658330145309,
        "excerpt": "    @classmethod\n    def from_dict(cls, data: Dict[str, Any]) -> \"CallHierarchyItem\":\n        return cls(\n            name=data[\"name\"],\n            kind=data[\"kind\"],\n            file_path=data[\"file...",
        "content": "    @classmethod\n    def from_dict(cls, data: Dict[str, Any]) -> \"CallHierarchyItem\":\n        return cls(\n            name=data[\"name\"],\n            kind=data[\"kind\"],\n            file_path=data[\"file_path\"],\n            range=Range.from_dict(data[\"range\"]),\n            detail=data.get(\"detail\"),\n        )\n\n\n@dataclass\nclass CodeSymbolNode:\n\n    id: str\n    name: str\n    kind: str\n    file_path: str\n    range: Range\n    embedding: Optional[List[float]] = None\n    raw_code: str = \"\"\n    docstring: str = \"\"\n    score: float = 0.0\n\n    def __post_init__(self) -> None:\n        if not self.id:\n            raise ValueError(\"id cannot be empty\")\n        if not self.name:\n            raise ValueError(\"name cannot be empty\")\n        if not self.kind:\n            raise ValueError(\"kind cannot be empty\")\n        if not self.file_path:\n            raise ValueError(\"file_path cannot be empty\")\n\n    def __hash__(self) -> int:\n        return hash(self.id)\n\n    def __eq__(self, other: object) -> bool:\n        if not isinstance(other, CodeSymbolNode):\n            return False\n        return self.id == other.id\n\n    def to_dict(self) -> Dict[str, Any]:\n",
        "source": null,
        "symbol": null
      },
      {
        "path": "D:\\Claude_dms3\\codex-lens\\src\\codexlens\\cli\\commands.py",
        "score": 0.056576452190618645,
        "excerpt": "from rich.table import Table\n\nfrom codexlens.config import Config\nfrom codexlens.entities import IndexedFile, SearchResult, Symbol\nfrom codexlens.errors import CodexLensError, ConfigError, ParseError,...",
        "content": "import os\nimport shutil\nimport sqlite3\nfrom pathlib import Path\nfrom typing import Annotated, Any, Dict, Iterable, List, Optional\n\nimport typer\nfrom rich.progress import BarColumn, Progress, SpinnerColumn, TextColumn, TimeElapsedColumn\nfrom rich.table import Table\n\nfrom codexlens.config import Config\nfrom codexlens.entities import IndexedFile, SearchResult, Symbol\nfrom codexlens.errors import CodexLensError, ConfigError, ParseError, StorageError, SearchError\nfrom codexlens.parsers.factory import ParserFactory\nfrom codexlens.storage.path_mapper import PathMapper\nfrom codexlens.storage.registry import RegistryStore, ProjectInfo\nfrom codexlens.storage.index_tree import IndexTreeBuilder\nfrom codexlens.storage.dir_index import DirIndexStore\nfrom codexlens.search.chain_search import ChainSearchEngine, SearchOptions\nfrom codexlens.watcher import WatcherManager, WatcherConfig\n",
        "source": null,
        "symbol": null
      },
      {
        "path": "D:\\Claude_dms3\\codex-lens\\src\\codexlens\\config.py",
        "score": 0.05655744432847353,
        "excerpt": "\"\"\"Configuration system for CodexLens.\"\"\"\n\nfrom __future__ import annotations",
        "content": "\"\"\"Configuration system for CodexLens.\"\"\"\n\nfrom __future__ import annotations\n\nimport json\nimport logging\nimport os\nfrom dataclasses import dataclass, field\nfrom functools import cached_property\nfrom pathlib import Path\nfrom typing import Any, Dict, List, Optional",
        "source": null,
        "symbol": null
      },
      {
        "path": "D:\\Claude_dms3\\codex-lens\\src\\codexlens\\search\\chain_search.py",
        "score": 0.049219375000264694,
        "excerpt": "\nfrom concurrent.futures import ThreadPoolExecutor, as_completed\nfrom dataclasses import dataclass, field\nfrom pathlib import Path\nfrom typing import List, Optional, Dict, Any, Literal, Tuple, TYPE_CH...",
        "content": "\"\"\"Chain search engine for recursive multi-directory searching.\n\nProvides parallel search across directory hierarchies using indexed _index.db files.\nSupports depth-limited traversal, result aggregation, and symbol search.\n\"\"\"\n\nfrom __future__ import annotations\n\nfrom concurrent.futures import ThreadPoolExecutor, as_completed\nfrom dataclasses import dataclass, field\nfrom pathlib import Path\nfrom typing import List, Optional, Dict, Any, Literal, Tuple, TYPE_CHECKING\nimport json\nimport logging\nimport os\nimport time\n\nfrom codexlens.entities import SearchResult, Symbol\n\nif TYPE_CHECKING:",
        "source": null,
        "symbol": null
      },
      {
        "path": "D:\\Claude_dms3\\codex-lens\\src\\codexlens\\indexing\\embedding.py",
        "score": 0.047931429239828446,
        "excerpt": "    def __init__(\n        self,\n        model_name: Optional[str] = None,\n        use_gpu: bool = True,\n        expand_dim: bool = True,\n    ) -> None:\n        from codexlens.semantic import SEMANTIC_...",
        "content": "    def __init__(\n        self,\n        model_name: Optional[str] = None,\n        use_gpu: bool = True,\n        expand_dim: bool = True,\n    ) -> None:\n        from codexlens.semantic import SEMANTIC_AVAILABLE\n\n        if not SEMANTIC_AVAILABLE:\n            raise ImportError(\n                \"Semantic search dependencies not available. \"\n                \"Install with: pip install codexlens[semantic]\"\n            )\n\n        self._model_name = model_name or self.DEFAULT_MODEL\n        self._use_gpu = use_gpu\n        self._expand_dim = expand_dim\n        self._model = None\n        self._native_dim: Optional[int] = None\n\n        \n        self._expansion_matrix: Optional[np.ndarray] = None\n\n    @property\n    def model_name(self) -> str:\n        return self._model_name\n\n    @property\n    def embedding_dim(self) -> int:\n        if self._expand_dim:\n            return self.TARGET_DIM\n        \n        if self._native_dim is not None:\n            return self._native_dim\n        \n        model_dims = {\n            \"BAAI/bge-large-en-v1.5\": 1024,\n            \"BAAI/bge-base-en-v1.5\": 768,\n            \"BAAI/bge-small-en-v1.5\": 384,\n            \"intfloat/multilingual-e5-large\": 1024,\n        }\n        return model_dims.get(self._model_name, 1024)\n\n    @property\n    def max_tokens(self) -> int:\n        return 512  \n\n",
        "source": null,
        "symbol": null
      },
      {
        "path": "D:\\Claude_dms3\\codex-lens\\src\\codexlens\\semantic\\rotational_embedder.py",
        "score": 0.04283104206542711,
        "excerpt": "import threading\nimport time\nfrom dataclasses import dataclass, field\nfrom enum import Enum\nfrom typing import Any, Dict, Iterable, List, Optional",
        "content": "Provides intelligent load balancing across multiple LiteLLM embedding endpoints\nto maximize throughput while respecting rate limits.\n\"\"\"\n\nfrom __future__ import annotations\n\nimport logging\nimport random\nimport threading\nimport time\nfrom dataclasses import dataclass, field\nfrom enum import Enum\nfrom typing import Any, Dict, Iterable, List, Optional\n\nimport numpy as np\n\nfrom .base import BaseEmbedder\n\nlogger = logging.getLogger(__name__)\n\n",
        "source": null,
        "symbol": null
      },
      {
        "path": "D:\\Claude_dms3\\codex-lens\\src\\codexlens\\lsp\\standalone_manager.py",
        "score": 0.036886112765573215,
        "excerpt": "- Direct subprocess spawning of language servers\n- JSON-RPC 2.0 communication over stdin/stdout\n- Multi-language support via configuration file (lsp-servers.json)\n- Process lifecycle management with a...",
        "content": "\"\"\"Standalone Language Server Manager for direct LSP communication.\n\nThis module provides direct communication with language servers via JSON-RPC over stdio,\neliminating the need for VSCode Bridge. Similar to cclsp architecture.\n\nFeatures:\n- Direct subprocess spawning of language servers\n- JSON-RPC 2.0 communication over stdin/stdout\n- Multi-language support via configuration file (lsp-servers.json)\n- Process lifecycle management with auto-restart\n- Compatible interface with existing LspBridge\n\"\"\"\n\nfrom __future__ import annotations\n\nimport asyncio\nimport json\nimport logging\nimport os",
        "source": null,
        "symbol": null
      },
      {
        "path": "D:\\Claude_dms3\\codex-lens\\src\\codexlens\\api\\models.py",
        "score": 0.03448209080810879,
        "excerpt": "        container: Containing class/module (if any)\n        score: Match score for ranking\n        return {k: v for k, v in asdict(self).items() if v is not None}\n\n\n# =================================...",
        "content": "        container: Containing class/module (if any)\n        score: Match score for ranking\n        return {k: v for k, v in asdict(self).items() if v is not None}\n\n\n# =============================================================================\n# Section 4.4: find_references dataclasses\n# =============================================================================\n\n@dataclass\nclass ReferenceResult:\n    file_path: str\n    line: int\n    column: int\n    context_line: str\n    relationship: str  # call | import | type_annotation | inheritance\n\n    def to_dict(self) -> dict:\n        return asdict(self)\n\n\n@dataclass\nclass GroupedReferences:\n    definition: DefinitionResult\n    references: List[ReferenceResult] = field(default_factory=list)\n\n    def to_dict(self) -> dict:\n        return {\n            \"definition\": self.definition.to_dict(),\n            \"references\": [r.to_dict() for r in self.references],\n        }\n\n\n",
        "source": null,
        "symbol": null
      },
      {
        "path": "D:\\Claude_dms3\\codex-lens\\src\\codexlens\\parsers\\treesitter_parser.py",
        "score": 0.03341093379138448,
        "excerpt": "\n        if TREE_SITTER_AVAILABLE:\n            self._initialize_parser()\n\n    def _initialize_parser(self) -> None:\n        if TreeSitterParser is None or TreeSitterLanguage is None:\n            retur...",
        "content": "\n        if TREE_SITTER_AVAILABLE:\n            self._initialize_parser()\n\n    def _initialize_parser(self) -> None:\n        if TreeSitterParser is None or TreeSitterLanguage is None:\n            return\n\n        try:\n            \n            if self.language_id == \"python\":\n                import tree_sitter_python\n                self._language = TreeSitterLanguage(tree_sitter_python.language())\n            elif self.language_id == \"javascript\":\n                import tree_sitter_javascript\n                self._language = TreeSitterLanguage(tree_sitter_javascript.language())\n            elif self.language_id == \"typescript\":\n                import tree_sitter_typescript\n                \n                if self.path is not None and self.path.suffix.lower() == \".tsx\":\n                    self._language = TreeSitterLanguage(tree_sitter_typescript.language_tsx())\n                else:\n                    self._language = TreeSitterLanguage(tree_sitter_typescript.language_typescript())\n            else:\n                return\n\n            \n            self._parser = TreeSitterParser()\n            if hasattr(self._parser, \"set_language\"):\n                self._parser.set_language(self._language)  \n            else:\n                self._parser.language = self._language  \n\n        except Exception:\n            \n            self._parser = None\n            self._language = None\n\n    def is_available(self) -> bool:\n        return self._parser is not None and self._language is not None\n\n    def _parse_tree(self, text: str) -> Optional[tuple[bytes, TreeSitterNode]]:\n        if not self.is_available() or self._parser is None:\n",
        "source": null,
        "symbol": null
      },
      {
        "path": "D:\\Claude_dms3\\codex-lens\\src\\codexlens\\watcher\\incremental_indexer.py",
        "score": 0.029568673189485736,
        "excerpt": "\nimport logging\nfrom dataclasses import dataclass\nfrom pathlib import Path\nfrom typing import List, Optional",
        "content": "\"\"\"Incremental indexer for processing file changes.\"\"\"\n\nfrom __future__ import annotations\n\nimport logging\nfrom dataclasses import dataclass\nfrom pathlib import Path\nfrom typing import List, Optional\n\nfrom codexlens.config import Config\nfrom codexlens.parsers.factory import ParserFactory\nfrom codexlens.storage.dir_index import DirIndexStore\nfrom codexlens.storage.global_index import GlobalSymbolIndex\nfrom codexlens.storage.path_mapper import PathMapper\nfrom codexlens.storage.registry import RegistryStore\n",
        "source": null,
        "symbol": null
      }
    ],
    "stats": {
      "dirs_searched": 17,
      "files_matched": 10,
      "time_ms": 6667.8361892700195
    }
  }
}
